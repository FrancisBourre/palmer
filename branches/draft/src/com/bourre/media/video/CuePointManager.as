/* * Copyright the original author or authors. *  * Licensed under the MOZILLA PUBLIC LICENSE, Version 1.1 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.mozilla.org/MPL/MPL-1.1.html *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.bourre.media.video {
	import com.bourre.collections.HashMap;	import com.bourre.core.palmer_internal;	import com.bourre.exceptions.IllegalArgumentException;	import com.bourre.log.PalmerDebug;	import com.bourre.log.PalmerStringifier;	import com.bourre.structures.Range;			use namespace palmer_internal;		
	/**
	 * VideoStream cue points manager.	 * 	 * @author Romain Ecarnot
	 */
	public class CuePointManager 	{		//--------------------------------------------------------------------		// Private properties		//--------------------------------------------------------------------		private var _oOwner : VideoStream;		private var _nCueIndex : int;		private var _nTolerance : Number;						//--------------------------------------------------------------------		// Protected properties		//--------------------------------------------------------------------				/** Cue points collection. */		protected var collection : HashMap;				//--------------------------------------------------------------------		// Public properties		//--------------------------------------------------------------------				/**		 * 		 */		public function get length( ) : uint		{			return collection.size( );			}				/**		 * in seconde.		 */		public function get tolerance() : Number		{			return _nTolerance;		}		/** @private */		public function set tolerance( value : Number ) : void		{			_nTolerance = value;		}						//--------------------------------------------------------------------		// Public API		//--------------------------------------------------------------------				/**		 * 		 */		public function CuePointManager( owner : VideoStream )		{			_oOwner = owner;						_nCueIndex = -1;			_nTolerance = 0.5;						collection = new HashMap( );		}		/**		 * Returns VideoStream owner.		 */		public function getOwner(  ) : VideoStream		{			return _oOwner;		}				/**		 * Returns cue points list.		 * 		 * @return The cue points list.		 */		public function getCuePoints() : Vector.<CuePoint>		{			var list : Vector.<CuePoint> = new Vector.<CuePoint>( );			var a : Array = collection.getValues( );							for (var i : int = 0; i < a.length ; i++) list.push( a[i] );			list.sort( sortPoints );						return list;		}		/**		 *  		 */		public function addCuePoint( data : Object ) : void		{			var msg : String;						var time : Number = data.hasOwnProperty( "time" ) ? data.time : null;						if ( ( isNaN( time ) || time < 0 ) )			{				msg = this + ".addCuePoint() failed. Time property is invalid : " + data.time;				PalmerDebug.ERROR( msg );				throw( new IllegalArgumentException( msg ) );			}						var name : String = data.hasOwnProperty( "name" ) ? data.name : null;			if (!name )			{				msg = this + ".addCuePoint() failed. Name property is invalid : " + data.time;				PalmerDebug.ERROR( msg );				throw( new IllegalArgumentException( msg ) );			}						var cp : CuePoint;						if( !(data is CuePoint) )			{				cp = new CuePoint( );				cp.name = name;				cp.time = time;				cp.type = data.hasOwnProperty( "type" ) ? data.type : CuePoint.ACTIONSCRIPT_TYPE;				cp.parameters = data.hasOwnProperty( "parameters" ) ? data.parameters : [];			}			else cp = data as CuePoint;						if( collection.containsKey( cp.time ) )			{				var stored : CuePoint = collection.get( cp.time );				stored.name = cp.name;				stored.type = cp.type;				stored.parameters = cp.parameters;			}			else			{				collection.put( cp.time, cp );			}		}				/**		 * 		 */		public function addCuePoints( a : Array ) : void		{			var l : uint = a.length;			for (var i : uint = 0; i < l ; i++) 			{				addCuePoint( a[i] );			}		}		/**		 *		 */		public function removeCuePoint( cp : CuePoint ) : void		{			removeCuePointByTime( cp.time );		}		/**		 *		 */		public function removeCuePointByName( name : String ) : void		{			var list : Vector.<CuePoint> = getCuePoints( );						for each (var cp : CuePoint in list) 			{				if( cp.name == name ) removeCuePointByTime( ( cp.time ) );			}		}		/**		 *		 */		public function removeCuePointByTime( time : Number ) : void		{			if( collection.containsKey( time ) )			{				collection.remove( time );			}		}		/**		 * 		 */		public function removeAllCuePoints( ) : void		{			collection = new HashMap( );		}				/**		 * 		 */		palmer_internal function getCuePoint( time : Number ) : CuePoint		{			var list : Vector.<CuePoint> = getCuePoints();						if( list == null || list.length < 1 ) return null;						if( isNaN( time ) || time < 0 )			{				PalmerDebug.ERROR( getOwner() + ".getCuePoint() failed. Invalid time : " + time );				return null;			}						var index : int = _nCueIndex;			var l : Number = list.length;			var bounds : Range = new Range( time - tolerance, time + tolerance );						while( --l > -1 ) if ( bounds.surround( list[ l ].time ) ) index = l;						if( index != _nCueIndex ) 			{				_nCueIndex = index;				return list[ index ];			}			else return null;		}				/**		 * Returns string representation of instance.		 * 		 * @return A string representation of instance.		 */		public function toString(  ) : String		{			var s : String = PalmerStringifier.stringify( this ) + "<" + getOwner( ) + ">[" + length + "]";			var list : Vector.<CuePoint> = getCuePoints( );						for each (var cp : Object in list) 			{				s += "\n" + "{ name : " + cp.name + ", time : " + cp.time + " }";			}						return s;		}					//--------------------------------------------------------------------		// Protected methods		//--------------------------------------------------------------------				/**		 * Sorts cue points using time comparaison.		 */		protected function sortPoints( a : CuePoint, b : CuePoint ) : Number		{			if( a.time < b.time ) return -1;			else if ( a.time == b.time ) return 0;						return 1;		}
	}
}
