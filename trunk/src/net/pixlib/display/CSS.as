/* * Copyright the original author or authors. *  * Licensed under the MOZILLA PUBLIC LICENSE, Version 1.1 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.mozilla.org/MPL/MPL-1.1.html *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package net.pixlib.display {	import net.pixlib.collections.HashMap;	import net.pixlib.commands.Delegate;	import net.pixlib.log.PalmerDebug;	import net.pixlib.log.PalmerStringifier;	import flash.filters.BlurFilter;	import flash.text.Font;	import flash.text.StyleSheet;	import flash.text.TextField;	/**	 * CSS custom StyleSheet object.	 * 	 * @author Romain Ecarnot	 */	public class CSS	{		//--------------------------------------------------------------------		// Private properties		//--------------------------------------------------------------------		private var _sName : String;				//--------------------------------------------------------------------		// Protected properties		//--------------------------------------------------------------------				/** Current embed Stylesheet object. */		protected var oCSS : StyleSheet;		/** Style applying methods map. */		protected var mMethods : HashMap;		/** Created TextFormat cache. */		protected var mCache : HashMap;				//--------------------------------------------------------------------		// Public API		//--------------------------------------------------------------------				/**		 * Creates new instance.		 * 		 * <p>Some property parser are automatically defined in constructor :		 * <ul>		 * 	<li>Color</li>		 * 	<li>Font family</li>		 * 	<li>Font size</li>		 * 	<li>Font style</li>		 * 	<li>Font weight</li>		 * 	<li>Text align</li>		 * 	<li>Left margin</li>		 * 	<li>Right margin</li>		 * 	<li>Background color</li>		 * </ul></p>		 * 		 * @param	name	Instance identifier		 * @param	css		StyleSheet object		 * 		 * @see addParser()		 */		public function CSS( name : String = null, css : StyleSheet = null )		{			mMethods = new HashMap( ) ;			mMethods.put( "color", checkColor );			mMethods.put( "fontFamily", checkFont );			mMethods.put( "fontSize", checkSize );			mMethods.put( "fontWeight", checkWeight );			mMethods.put( "fontStyle", checkItalic );			mMethods.put( "textAlign", checkBackground );			mMethods.put( "backgroundColor", checkAlign );			mMethods.put( "marginLeft", checkLeftMargin );			mMethods.put( "marginRight", checkRightMargin );						mCache = new HashMap( );						setName( name );			setStyleSheet( css );		}		/**		 * Returns CSS instance identifier.		 */		public function getName(  ) : String		{			return _sName;		}		/**		 * Sets the CSS instance identifier.		 * 		 * @param	name	Instance identifier		 */		public function setName( name : String ) : void		{			if( name != null )			{				_sName = name;								if ( !(CSSLocator.getInstance( ).isRegistered( getName( ) )) )				{					CSSLocator.getInstance( ).register( getName( ), this );				}				else				{					var msg : String = this + " can't be registered to " + CSSLocator.getInstance( ) + " with '" + getName( ) + "' name. This name already exists.";					PalmerDebug.ERROR( msg, this );				}			}		}		/**		 * Returns embed StyleSheet object.		 * 		 * @return embed StyleSheet object.		 */		public function getStyleSheet(  ) : StyleSheet		{			return oCSS;		}		/**		 * Sets the stylesheet to use.		 * 		 * @param css	StyleSheet to use		 */		public function setStyleSheet( css : StyleSheet ) : void		{			oCSS = css;		}		/**		 * Clears TextFormat buffer.		 */		public function clearCache(  ) : void		{			mCache.clear( );			mCache = new HashMap( );		}		/**		 * Adds or sets the method to use to apply passed-in <code>property</code> 		 * style in CSS.		 * 		 * @param	property		Style property to check		 * @param	parsingMedtod	Method to use to apply property		 */		public function addPropertyParser( property : String, parsingMethod : Function ) : void		{			mMethods.put( property, parsingMethod );		}				/**		 * Applies passed-in <code>styleName</code> style to <code>field</code> 		 * TexField object.		 * 		 * <p>Uses custom methods defined using <code>addParser()</code> to built 		 * TextFormat object.</p>		 * 		 * <p>A TextFormat object is automatically created and saved into 		 * cache system.</p>		 * 		 * @param	styleName	Style name (in current StyleSheet) to apply		 * @param	field		Targeted TextField object		 * 		 * @see addParser()		 * @see clearCache()		 */		public function applyStyle( styleName : String, field : TextField = null, beginIndex : int = -1, endIndex : int = -1 ) : CSSStyleFormat		{			try			{				if( mCache.containsKey( styleName ) )				{					return mCache.get( styleName );				}								var tf : CSSStyleFormat = new CSSStyleFormat( );				var style : Object = getStyle(styleName);								for( var property : String in style )				{					applyStyleProperty( property, styleName, tf, field );					}								if ( field ) 				{					field.setTextFormat( tf, beginIndex, endIndex );										if( field.length == 0 ) field.defaultTextFormat = tf;				}								mCache.put( styleName, tf );								return tf;			}			catch( e : Error )			{				PalmerDebug.ERROR( this + ".applyStyle( " + styleName + " ) failed." + e.message, this );			}						return null;		}		/**		 * Returns Object style.		 */		public function getStyle( styleName : String ) : Object		{			var a : Array = styleName.split( "." );			var style : String;			var o : Object = {};						for( var i : uint = 0; i < a.length ; i++ )			{				style = !i ? a[i] : style + "." + a[i];								var po : Object = oCSS.getStyle( style );				if( po != null ) for( var p : String in po ) o[p] = formatProperty( po[p] );				}						return o;		}				/**		 * Adds a new style with the specified name to the style sheet object.		 * 		 * @param styleName		Name of the style to add.		 * @param styleObject	Object that describes the style.		 */		public function setStyle( styleName : String, styleObject : Object ) : void		{			oCSS.setStyle(styleName, styleObject);		}				/**		 * Parses the passed-in CSS text definition.		 * 		 * @param cssText	The CSS text to parse		 */		public function parseCSS( cssText : String ) : void		{			oCSS.parseCSS( cssText );		}				/**		 * Returns <code>true</code> if <code>styleName</code> contains 		 * <code>property</code> property.		 * 		 * @param	styleName	Style name (in current StyleSheet) to use		 * @param	property	Style property to check		 * 		 * @return <code>true</code> if <code>styleName</code> contains 		 * <code>property</code> property.		 */		public function hasProperty( styleName : String, property : String ) : Boolean		{			var style : Object = getStyle( styleName );						return style.hasOwnProperty( property );		}		/**		 * Returns style property.		 * 		 * @param	styleName		Style name (in current StyleSheet) to use		 * @param	property		Style property to check		 * @param	defaultValue	(optional) Default value to use if property 		 * 							is not defined.		 * 		 * @return <code>property</code> value in passed-in <code>styleName</code> style.		 */		public function getProperty( styleName : String, property : String, defaultValue : * = null ) : String		{			var style : Object = getStyle(styleName);						if( style != null )			{				if( style.hasOwnProperty( property ) )				{					return formatProperty( style[property]);				}			}			else			{				PalmerDebug.ERROR( this + ".getProperty(" + styleName +") failed! Style is not registered.", this );			}						return defaultValue;		}		/**		 * Returns style property (Number cast)		 * 		 * @param	styleName		Style name (in current StyleSheet) to use		 * @param	property		Style property to check		 * @param	defaultValue	(optional) Default value to use if property 		 * 							is not defined.		 * 		 * @return <code>property</code> value in passed-in <code>styleName</code> style.		 */		public function getNumber( styleName : String, property : String, defaultValue : Number = 0 ) : Number		{			var value : String = getProperty( styleName, property, defaultValue );						if( value.indexOf( "#" ) == 0 )			{				return _stringToHexa( value );			}						var n : Number = parseFloat( value );						if( !isNaN( n ) ) return n;			else return defaultValue;		}		/**		 * Returns style property (Boolean cast)		 * 		 * @param	styleName		Style name (in current StyleSheet) to use		 * @param	property		Style property to check		 * @param	defaultValue	(optional) Default value to use if property 		 * 							is not defined.		 * 		 * @return <code>property</code> value in passed-in <code>styleName</code> style.		 */		public function getBoolean( styleName : String, property : String, defaultValue : Boolean = true ) : Boolean		{			var s : String = getProperty( styleName, property );						if( s && s.length > 0 )			{				return new Boolean( s == "true" || !isNaN( Number( s ) ) && Number( s ) != 0 );			}			else return defaultValue;		}		/**		 * Creates and returns a new TextField with <code>stylename</code> style applied.		 * 		 * @param	styleName	Style to apply to the new created TextField		 * 		 * @return a new TextField with <code>stylename</code> style applied		 */		public function createTextField( styleName : String = null ) : TextField		{			var tf : TextField = new TextField( );						if( styleName != null ) applyStyle( styleName, tf );						return tf;		}		/**		 * Returns string representation of instance.		 * 		 * @return The string representation of instance.		 */		public function toString() : String		{			return PalmerStringifier.stringify( this );		}				//--------------------------------------------------------------------		// Protected methods		//--------------------------------------------------------------------				/**		 * 		 */		final protected function formatProperty( value : String ) : String		{			return value = value.split( "px" ).join( "" );		}				/**		 * Applies passed-in property style.		 */		protected function applyStyleProperty( property : String, styleName : String, tf : CSSStyleFormat, field : TextField = null ) : void		{			if ( mMethods.containsKey( property ) )			{				var d : Function = mMethods.get( property );				d.apply( this, [ tf, styleName, field ] );			} 			else			{				PalmerDebug.WARN( property + " type is not supported!" );			}		}		/**		 * @private		 */		protected function checkFont( tf : CSSStyleFormat, styleName : String, field : TextField = null ) : void		{			var value : String = getProperty( styleName, "fontFamily", null );						if( value != null ) 			{				tf.font = value;								if( field )					field.embedFonts = Font.enumerateFonts( ).filter( Delegate.create( _isEmbed, value ) ).length > 0;			}						if( field && !field.embedFonts )			{				var filters : Array = field.filters;				filters.push( new BlurFilter( 0, 0, 0 ) );				field.filters = filters;								PalmerDebug.WARN( "Font '" + value + "' is not embed" );			}		}			/**		 * @private		 */		protected function checkColor( tf : CSSStyleFormat, styleName : String, field : TextField = null ) : void		{			var value : String = getProperty( styleName, "color", null );						if( value != null ) tf.color = _stringToHexa( value );				}			/**		 * @private		 */		protected function checkSize( tf : CSSStyleFormat, styleName : String, field : TextField = null ) : void		{			var value : Number = getNumber( styleName, "fontSize", Number.NaN );						if( !isNaN( value ) ) tf.size = value;			}			/**		 * @private		 */		protected function checkWeight( tf : CSSStyleFormat, styleName : String, field : TextField = null ) : void		{			tf.bold = ( getProperty( styleName, "fontWeight", "normal" ) == "bold" );			}			/**		 * @private		 */		protected function checkItalic( tf : CSSStyleFormat, styleName : String, field : TextField = null ) : void		{			tf.italic = getProperty( styleName, "fontStyle", "normal" ) == "italic";			}		/**		 * @private		 */		protected function checkLeftMargin( tf : CSSStyleFormat, styleName : String, field : TextField = null ) : void		{			var marginLeft : Number = getNumber( styleName, "marginLeft", Number.NaN );			if( !isNaN( marginLeft ) ) tf.leftMargin = marginLeft;			}		/**		 * @private		 */		protected function checkRightMargin( tf : CSSStyleFormat, styleName : String, field : TextField = null ) : void		{			var marginRight : Number = getNumber( styleName, "marginRight", Number.NaN );			if( !isNaN( marginRight ) ) tf.rightMargin = marginRight;		}		/**		 * @private		 */		protected function checkBackground( tf : CSSStyleFormat, styleName : String, field : TextField = null ) : void		{			var enabled : Boolean = ( getProperty( styleName, "backgroundColor" ) != null );						if( enabled && ( field != null ) )			{				field.background = true;				field.backgroundColor = _stringToHexa( getProperty( styleName, "backgroundColor" ) );			}		}		/**		 * @private		 */		protected function checkAlign( tf : CSSStyleFormat, styleName : String, field : TextField = null ) : void		{			var value : String = getProperty( styleName, "textAlign", null );						if( value != null ) tf.align = value;		}					//--------------------------------------------------------------------		// Private implementation		//--------------------------------------------------------------------				/**		 * @private		 */		private function _isEmbed( element : *, index : int, arr : Array, testedFont : String ) : Boolean		{			return (element.fontName == testedFont );		}		/**		 * Transforms the passed-in string to hexa number.		 */		private static function _stringToHexa( str : String ) : int		{			str = str.substr( -6, 6 );			return parseInt( str, 16 ) as int;		}			}}