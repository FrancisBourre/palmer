/* * Copyright the original author or authors. *  * Licensed under the MOZILLA PUBLIC LICENSE, Version 1.1 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.mozilla.org/MPL/MPL-1.1.html *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.bourre.log.layout {	import com.bourre.collections.HashMap;	import com.bourre.exceptions.PrivateConstructorException;	import com.bourre.log.LogEvent;	import com.bourre.log.LogLevel;	import com.bourre.log.LogListener;	import com.bourre.log.PalmerStringifier;	import flash.events.Event;	/**	 * The <code>DeMonsterDebuggerLayout</code> class provides a convenient way	 * to output messages through DeMonsterDebugger application.	 * 	 * <p>Just provide the DeMonsterDebugger Client class to the layout 	 * to allow communication.</p>	 * 	 * <p>To get more details, visit: http://www.demonsterdebugger.com/</p>	 * 	 * @example	 * <pre class="prettyprint">	 * 	 * var layout : DeMonsterDebuggerLayout = DeMonsterDebuggerLayout.getInstance( );	 * layout.setClientClass( MonsterDebugger, this, true );	 * 	 * Logger.getInstance().addLogListener( layout, PalmerDebug.CHANNEL );	 * </pre>	 * 	 * @author Romain Ecarnot	 */	public class DeMonsterDebuggerLayout implements LogListener	{		//--------------------------------------------------------------------		// Private properties		//--------------------------------------------------------------------		private static  var _oI : DeMonsterDebuggerLayout ;						//--------------------------------------------------------------------		// Protected properties		//--------------------------------------------------------------------				/** DeMonsterDebugger Client class. */		protected var oClientClass : Class;				/** Hashmap to store LogLevel / color pair. */		protected var mColorLevel : HashMap;						//--------------------------------------------------------------------		// Public properties		//--------------------------------------------------------------------				/**		 * Method name in DeMonsterDebugger to trace ouput message.		 * 		 * @default trace		 */		public static var DEBUG_METHOD : String = "trace";				/**		 * Method name in DeMonsterDebugger to clear ouput messages.		 * 		 * @default clearTraces		 */		public static var CLEAR_METHOD : String = "clearTraces";				/**		 * The depth of the trace.		 * 		 * @default 4		 */		public static var DEPTH : uint = 4;				/**		 * Display the public methods of a Class in the output panel.		 * 		 * @default false		 */		public static var FUNCTIONS : Boolean = false;						//--------------------------------------------------------------------		// Public API		//--------------------------------------------------------------------				/**		 * Returns singleton instance of <code>DeMonsterDebuggerLayout</code> class.		 * 		 * @return The singleton instance of <code>DeMonsterDebuggerLayout</code> class.		 */			public static function getInstance( ) : DeMonsterDebuggerLayout		{			if ( !(DeMonsterDebuggerLayout._oI is DeMonsterDebuggerLayout) ) 				DeMonsterDebuggerLayout._oI = new DeMonsterDebuggerLayout( ConstructorAccess.instance );							return DeMonsterDebuggerLayout._oI;		}				/**		 * Releases singleton instance.		 */		public static function release() : void		{			if ( DeMonsterDebuggerLayout._oI is DeMonsterDebuggerLayout ) DeMonsterDebuggerLayout._oI = null;		}				/**		 * Sets the DeMonsterDebugger client class to use has debugger proxy.		 * 		 * @param	clientClass	DeMonsterDebugger class		 * @param	rootTarget	(optional) Main application point ( Live application inspection )		 * @param	autoClear	(optional) Clears console when connected the first time (default is true)		 */		public function setClientClass( clientClass : Class, rootTarget : Object = null, autoClear  : Boolean = true ) : void		{						oClientClass = clientClass;						if( rootTarget != null )			{				new oClientClass( rootTarget );			}						if( autoClear ) onClear();		}				/**		 * @inheritDoc		 */		public function onLog( e : LogEvent ) : void		{			if( oClientClass.hasOwnProperty( DEBUG_METHOD) )			{				oClientClass[ DEBUG_METHOD ]( e.logTarget, e.message, mColorLevel.get( e.level ), FUNCTIONS, DEPTH );			}		}				/**		 * @inheritDoc		 */		public function onClear( e : Event = null ) : void		{			if( oClientClass.hasOwnProperty( CLEAR_METHOD ) )			{				oClientClass[ CLEAR_METHOD ]( );			}		}				/**		 * Returns string representation of instance.		 * 		 * @return The string representation of instance.		 */		public function toString() : String		{			return PalmerStringifier.stringify( this );		}						//--------------------------------------------------------------------		// Protected methods		//--------------------------------------------------------------------				protected function initColorMap(  ) : void		{			mColorLevel = new HashMap( );			mColorLevel.put( LogLevel.ALL, 0x666666 );			mColorLevel.put( LogLevel.DEBUG, 0x0086B3 );			mColorLevel.put( LogLevel.INFO, 0x00B32D );			mColorLevel.put( LogLevel.WARN, 0xB38600 );			mColorLevel.put( LogLevel.ERROR, 0xB32D00 );			mColorLevel.put( LogLevel.FATAL, 0xB3002D );		}						//--------------------------------------------------------------------		// Private implementation		//--------------------------------------------------------------------						/**		 * @private		 */		function DeMonsterDebuggerLayout( access : ConstructorAccess )		{			if ( !(access is ConstructorAccess) ) throw new PrivateConstructorException( );						initColorMap();		}	}}internal class ConstructorAccess {	static public const instance : ConstructorAccess = new ConstructorAccess( );}